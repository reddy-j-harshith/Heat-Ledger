Users

-> Implement the asymmetric encrpytion based identification - Done
-> Maintaining a database of users - Asymmetric Key based - Taken Care by the Wallet - Done
-> identification of users - Using the public key of the Users

Blockchain specific actions

-> Mine and Broadcast a block for validation,
	so that it can be green-lighted for including in the blockchain
-> A tranaction is broadcasted to others in the network
-> Mining a Block (Meeting a target value for finding a nonce and creation of a block)
-> Maintain a difficulty stat for the mining difficulty
-> Gossip the next transactions to the other nodes, so that new txns. can be included in the mempool

Local Database: - DONE

-> Blockchain copy - Done
-> UTXO Database - Done
-> Maintaining a mempool of unconfirmed transactions -> Slice - Done
-> map[string]*Merkle_Node: Merkle_Roots - Done
-> map[string]Transaction: Transactions - Done

Things to consider - Functions Declared

-> When a new block is being included to the local copy of the chain,
	compress the hash values of the block when a new block is mined
-> Selection of the transactions
-> Merkle tree making - DONE
-> After downloading all the blocks, the blockchain needs to be validated.
-> Extract UTXOs while downloading the chain

Models: - DONE
	
	type UTXO struct {
		txn_id string
		index  int32
		amount float64
		owner  string
	}

	type Transaction struct {
		tnx_id     string // SHA(SHA(from + to + amount + fee + timestamp))
		block_hash string // Parent block
		in_sz      int32
		out_sz     int32
		fee        float64
		inputs     []UTXO
		outputs    []UTXO
		timestamp  time.Time
	}

	type Block struct {
		block_hash    string // Primary Key
		block_height  int32
		previous_hash string
		nonce         int32
		difficulty    int32
		merkle_hash   string // Obtain the merkle root from the target node and send the list of transactions to build the local merkle tree
		timestamp     time.Time
	}

	type MerkleNode struct {
		value string // Concatenations of the left and right nodes
		left  *MerkleNode
		right *MerkleNode
		// Leaf nodes will contain the hash of the txid, and left / right are set in NIL
	}

	Making the Merkle Tree:
		1) Taking all the transactions in an array
		2) Create the hash array
		3) Store the transactions into the database:

			map[string]Transaction

		4) Construct the tree by repeatedly concatenating the hashes
		5) Set the left and the right of the nodes to NIL for the leaves
		6) After calculating the hash of the root and store it using a hashmap:

			map[string]*Merkle_Node

		7) Add this hash value to the block


		Successful Mining ----											----- Reject -----> Continue Block Creation
							  \										   /
	 						   |-----> Change into Validate mode -----|
							  /										   \
		Recieve a block ------											----- Accept -----> Onto the next block


On startup

	-> Poplulate the UTXO set, the Blockchain database, create the merkle tree and populate the Merkle_Roots database
	-> Request the mempool
	-> The Transactions database